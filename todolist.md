    Избавиться от всех ненужных зависимостей (математические библиотеки, загрузка изо и т.д.)

    Проще написать свою мат библиотеку для матриц и векторов под конкретные задачи, чем юзать эти неудобные либы. Которые в любом случае приходится допиливать.

    Реализовать окна и циклы (стейт машина). addViewport. glEnable(GL_DEPTH_TEST) внутри установки флагов и glClearColor(0.2f, 0.3f, 0.3f, 1.0f) внутри цикла. Окна на андроиде - на фрагментах.

    Написать нормальную инициализацию картинок в js. Сейчас в каждой итерации отрисовки текстуры проверка на bool init.

    Избавиться от приватных vertexShader fragmentShader в классе Шейдера. Необязательно их отделать выделять.

    GameLoop и viewport->set() для c++ и js. Monker clear для с++ и java. Для с++ и веба добавить функции создания текстур к окну. monk.createTexture(R.drawable.elli_walk, 1.1f, 0.5f); внутри движка создает текстуру для текущего окна - (добавить currentScreen в код движка).

    Локи для glVertexAttribPointer можно убрать из итераций отрисовки меша.

    Для удобства можно в конструкторе текстуры создание изображение из битмапа и ресурсов выделить в еще один внутренний объект (шейдер, меш и image).

    В андроид опенгл рисуется в отдельном потоке. И все вызовы опенгл надо производить в этом потоке. Поэтому нельзя сделать так: var texture1 = monk.createTexture("./img/elli_walk.png", 1.1, 0.5); Для андроида это ассинхронная операция, она вернет в texture1 пустой объект. А сам объект внутри monk.createTexture создастся позже. Выход простой - доступа к низкоуровневой текстуре нет, метод возвращает id. Внутри создается массив текстур. Поверх низкоуровневого класса написать высокоуровневый, который берет текстуры из массива по id если инициализированна, проверяет инициализацию, функция draw() только проверяет инициализацию и вызывает draw() текстуры, вложенной в массив.