    *Графика (графический объект)

    Все игровые движки инкапсулируют код создавая много уровней абстракции. Получается лапша из объектов. Один объект наследует второй, второй - третий. Из кучи мелких родительских и дочерних объектов собирается один большой. Который и выполняет унитарную функцию. При чем нет никакой необходимости разбивать этот объект на мелкие. Т.к. они не работают друг без друга и не используется нигде извне.

    То, с чем сталкиваешься в самом начале: шейдерная программа, шейдеры и мешбуфер, вертиксы, индексы и т.д. Шейдеры не работают без вертиксов, вертиксы без индексов, индексы без функции draw(). Нет никакого смысла, кроме идеологического, разбивать это на мелкие объекты.

	Внутри большинство движков - это лапша из объектов.

    Однако, впихивать все в один интерфейс - тоже не комильфо. Отдавая дань традиции я разбиваю графический объект на меш, шейдерную программу и функцию draw(). Матрицы трансформации лежат извне в классе Entity. Внутри меша - массивы вертиксов, индексов и другие координаты. А так же функции инициализации и апдейта. Внутри шейдерной программы - шейдеры, функции чтения шейдера, инициализации и апдейта. Функция draw() инкапсулирует апдейты.

    Функциональность, гибкость, юзабилити, минимализм (компонентность, унитарность и т.д).

    Пока что я не понимаю, зачем писать абстрактный класс "Графический объект" (drawable, rendered и т.д.) и отдельные классы для шейдеров, шейдерных программ, мешей и прочее.

    Идеалогически в движке есть графический объект представленный типами: тестура, рект. Их структура схожа. Они цепляются к Entity как компоненты и к Scene как ноды(актеры). Scene - менеджер графических объектов, в массиве которого и происходит обновление всей графики. Возможно, scene будет выполнять спрайтбатчинг.

    Графические ноды также могут объединятся в группы и слои. Может быть, например, отдельно реализованная группа - "окружение". Типа бэкграунд с паралаксом.